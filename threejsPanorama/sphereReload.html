<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - equirectangular panorama demo</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            background-color: #000000;
            margin: 0px;
            overflow: hidden;
        }
        
        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            color: #ffffff;
            padding: 5px;
            font-family: Monospace;
            font-size: 13px;
            font-weight: bold;
            text-align: center;
        }
        
        a {
            color: #ffffff;
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <div id="info"> <a href="http://threejs.org" target="_blank">three.js webgl</a> - equirectangular panorama
        <br /> Drag equirectangular texture into the page. </div>
    <script src="three.js"></script>
    <script src="js/renderers/Projector.js"></script>
    <script src="js/renderers/CanvasRenderer.js"></script>
    <script src="js/libs/stats.min.js"></script>
    <script>
        var camera, scene, projector, renderer;
        var objects = [];
        var raycaster, mouse; 
        
        var mesh, sinu, sinuG, sinuR;
        
        var isUserInteracting = false
            , onMouseDownMouseX = 0
            , onMouseDownMouseY = 0
            , lon = 0
            , onMouseDownLon = 0
            , lat = 0
            , onMouseDownLat = 0
            , phi = 0
            , theta = 0;
        init();
        animate();

        function init() {
            var container;
            container = document.getElementById('container');
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);
            camera.target = new THREE.Vector3(0, 0, 0);
            scene = new THREE.Scene();
            var light = new THREE.AmbientLight(0x404040); // soft white light
            var geometry = new THREE.SphereGeometry(500, 60, 40);
            geometry.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));
            var textureLoader = new THREE.TextureLoader();
            
            sinu = textureLoader.load('files/sinusoidal.png');
            sinuG = textureLoader.load('files/sinusoidal green.png');
            sinuR = textureLoader.load('files/sinusoidal red.png');
            
            var material = new THREE.MeshBasicMaterial({                
                map: sinu
            });
            
            
            mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            /*
            var geometry1 = new THREE.SphereGeometry( 25, 32, 32 );
            var material1 = new THREE.MeshBasicMaterial( {color: 0xff0000} );
            var sphere1 = new THREE.Mesh( geometry1, material1 );
            sphere1.position.set(-60, 55, 0);
            scene.add( sphere1 );
            */
            //
            //scene = new THREE.Scene();
            var mat1 = new THREE.MeshPhongMaterial({
                color: 0xff0000
                , specular: 0x009900
                , shininess: 70
                , shading: THREE.FlatShading
            });
            var wireRed = new THREE.MeshBasicMaterial({
                color: 0xff0000
                , wireframe: true
                    //,morphTargets: true
            });
            var wireGreen = new THREE.MeshBasicMaterial({
                color: 0x00ff00
                , wireframe: true
                    //,morphTargets: true
            });
            var geometry1 = new THREE.SphereBufferGeometry(32, 16, 16);
            objects[0] = new THREE.Mesh(geometry1, wireRed);
            objects[0].position.x = 0;
            objects[0].position.y = 0;
            objects[0].position.z = -500;
            objects[0].userData = {
                URL: "http://google.com"
            };
            /*object.scale.x = Math.random() * 2 + 1;
            object.scale.y = Math.random() * 2 + 1;
            object.scale.z = Math.random() * 2 + 1;
            object.rotation.x = Math.random() * 2 * Math.PI;
            object.rotation.y = Math.random() * 2 * Math.PI;
            object.rotation.z = Math.random() * 2 * Math.PI;
            */
            scene.add(objects[0]);
            objects[1] = new THREE.Mesh(geometry1, wireGreen);
            objects[1].position.x = 0;
            objects[1].position.y = 0;
            objects[1].position.z = +500;
            objects[1].userData = {
                URL: "sphereButtonExtra.html"
            };
            scene.add(objects[1]);
            scene.add(light);
            /*
                var material1 = new THREE.MeshNormalMaterial();
                var sphereGeometry = new THREE.SphereGeometry(30, 32, 16);
                var sphere1 = new THREE.Mesh(sphereGeometry, outlineMaterial1);
                //sphere1.position.set(-60, 55, 100);
                //sphere1.position.z = -100; 
                scene.add(sphere1);
                var outlineMaterial1 = new THREE.MeshBasicMaterial({
                    color: 0xff0000
                    , side: THREE.BackSide
                });
                var outlineMesh1 = new THREE.Mesh(sphereGeometry, outlineMaterial1);
                outlineMesh1.position = sphere1.position;
                outlineMesh1.scale.multiplyScalar(1.05);
                scene.add(outlineMesh1);
                //*/
            projector = new THREE.Projector();
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            document.addEventListener('mousedown', onDocumentMouseDown, false);
            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('mouseup', onDocumentMouseUp, false);
            document.addEventListener('mousewheel', onDocumentMouseWheel, false);
            document.addEventListener('DOMMouseScroll', onDocumentMouseWheel, false);
            //
            document.addEventListener('dragover', function (event) {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'copy';
            }, false);
            document.addEventListener('dragenter', function (event) {
                document.body.style.opacity = 0.5;
            }, false);
            document.addEventListener('dragleave', function (event) {
                document.body.style.opacity = 1;
            }, false);
            document.addEventListener('drop', function (event) {
                event.preventDefault();
                var reader = new FileReader();
                reader.addEventListener('load', function (event) {
                    material.map.image.src = event.target.result;
                    material.map.needsUpdate = true;
                }, false);
                reader.readAsDataURL(event.dataTransfer.files[0]);
                document.body.style.opacity = 1;
            }, false);
            //
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseDown(event) {
            event.preventDefault();
            isUserInteracting = true;
            onPointerDownPointerX = event.clientX;
            onPointerDownPointerY = event.clientY;
            onPointerDownLon = lon;
            onPointerDownLat = lat;
            var vector = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5);
            
            
            projector.unprojectVector(vector, camera);
            //var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
            raycaster.setFromCamera( mouse, camera );
            
            var intersects = raycaster.intersectObjects(objects);
            if (intersects.length > 0) {
               // window.open(intersects[0].object.userData.URL, "_self");
                mesh.material.map = sinuG;
            }
        }
        

        function onDocumentMouseMove(event) {
            if (isUserInteracting === true) {
                lon = (onPointerDownPointerX - event.clientX) * 0.1 + onPointerDownLon;
                lat = (event.clientY - onPointerDownPointerY) * 0.1 + onPointerDownLat;
            }
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

       
        
        window.addEventListener('mousemove', onMouseMove, false);
        window.requestAnimationFrame(render);

        function onDocumentMouseUp(event) {
            isUserInteracting = false;
        }

        function onDocumentMouseWheel(event) {
            // WebKit
            if (event.wheelDeltaY) {
                camera.fov -= event.wheelDeltaY * 0.05;
                // Opera / Explorer 9
            }
            else if (event.wheelDelta) {
                camera.fov -= event.wheelDelta * 0.05;
                // Firefox
            }
            else if (event.detail) {
                camera.fov += event.detail * 1.0;
            }
            camera.updateProjectionMatrix();
        }

        function onMouseMove(event) {
            // calculate mouse position in normalized device coordinates
            // (-1 to +1) for both components
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
            update();
        }
         function render() {
            // update the picking ray with the camera and mouse position	
            raycaster.setFromCamera(mouse, camera);
            // calculate objects intersecting the picking ray
            var intersects = raycaster.intersectObjects(objects);
            
            if (intersects.length > 0) {
                intersects[0].object.rotation.y += 0.02;
                //window.open(intersects[0].object.userData.URL, "_self");
            }
             // more than one intersect
             // for (var i = 0; i < intersects.length; i++) {
                //intersects[i].object.material.color.set(0x0000ff);
              //  intersects[i].object.rotation.x += 0.1;
            //}
             
             
            renderer.render(scene, camera);
        }

        function update() {
            if (isUserInteracting === false) {
                //	lon += 0.1;
            }
            lat = Math.max(-85, Math.min(85, lat));
            phi = THREE.Math.degToRad(90 - lat);
            theta = THREE.Math.degToRad(lon);
            camera.target.x = 500 * Math.sin(phi) * Math.cos(theta);
            camera.target.y = 500 * Math.cos(phi);
            camera.target.z = 500 * Math.sin(phi) * Math.sin(theta);
            camera.lookAt(camera.target);
            // distortion
            //camera.position.copy(camera.target).negate();
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>